#lang racket/base

(require rackunit 
         mrlib/image-core
         racket/class
         (only-in racket/gui/base make-bitmap))

;; just check there is no error
(check-equal? (begin (un/cache-image (make-bitmap 1 1) #t)
                     (void))
              (void))

(check-equal?
 (let ([b (make-bitmap 1 1)])
   (definitely-same-image? b b))
 #t)

(check-equal?
 (let* ([b (make-bitmap 1 1)])
   (define s1 (make-object image-snip% b))
   (define s2 (make-object image-snip% b))
   (definitely-same-image? s1 s2))
 #t)

(define (to-bytes b)
  (define width 50)
  (for/list ([i (in-range (ceiling (/ (bytes-length b) width)))])
    (subbytes b (* i width) (min (bytes-length b) (* (+ i 1) width)))))

(check-equal? (apply bytes-append (to-bytes #""))
              #"")
(check-equal? (apply bytes-append (to-bytes #"a"))
              #"a")
(check-equal? (apply bytes-append (to-bytes #"ab"))
              #"ab")
(let ([b (make-bytes 100)])
  (for ([i (in-range (bytes-length b))])
    (bytes-set! b i i))
  (check-equal? (apply bytes-append (to-bytes b))
                b))
(let ([b (make-bytes 101)])
  (for ([i (in-range (bytes-length b))])
    (bytes-set! b i i))
  (check-equal? (apply bytes-append (to-bytes b))
                b))
(let ([b (make-bytes 255)])
  (for ([i (in-range (bytes-length b))])
    (bytes-set! b i i))
  (check-equal? (apply bytes-append (to-bytes b))
                b))


(require (only-in racket/gui/base bitmap% bitmap-dc%))
(let ()
  (define bmp (make-object bitmap% 10 10))
  (define bdc (make-object bitmap-dc% bmp))
  (send bdc draw-ellipse 1 1 8 8)
  (send bdc set-bitmap #f)
  (define i (to-img bmp))

  (check-equal?
   (snipclass-bytes->image
    ;; the bytes for `i` as of version 7.3
    (bytes-append
     #"(#(struct:translate 5 5 #(struct:bitmap #(#\"\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\0\\0\\0\\377\\0\\0\\0\\377\\0\\0\\0\\377\\0\\0\\0\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\0\\0\\0\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\0\\0\\0\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\0\\0\\0\\377\\0\\0\\0\\377"
     #"\\0\\0\\0\\377\\0\\0\\0\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\3"
     #"77\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377\\377"
     #"\\377\\377\\377\\377\\377\\377\" 10 10) 0 1 1 #hash())) #"
     #"(struct:bb 10 10 10) #f)"))
   i))
